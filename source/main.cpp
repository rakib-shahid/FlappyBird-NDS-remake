#include <nds.h>
#include <gl2d.h>
#include <stdio.h>
#include <cstdlib>
#include <ctime>
#include <maxmod9.h>

#include "soundbank.h"
#include "soundbank_bin.h"
#include "pipeTop.h"
#include "bird.h"
#include "birdUp.h"
#include "birdDown.h"
#include "bgLong.h"
#include "floor.h"
// using namespace SNF;
//  classes to keep track of variables
class Pipe
{
public:
    int pipeX;
    int pipeY;
};
class Bird
{
public:
    int xPos;
    int yPos;
};

// clrscr function taken from libnds practical wiki https://github.com/NotImplementedLife/libnds-practical-wiki
inline void clrscr() { iprintf("\e[1;1H\e[2J"); }

int main()
{
    consoleDemoInit();

    // Initialize Maxmod sound engine
    mmInitDefaultMem((mm_addr)soundbank_bin);
    // load sound effects
    mmLoadEffect(SFX_DING);
    mmLoadEffect(SFX_FLAP);
    mmLoadEffect(SFX_SMACK);
    mmLoadEffect(SFX_SMACKWHOOSHQUICK);
    mmLoadEffect(SFX_SMACKWHOOSHSLOW);
    mmLoadEffect(SFX_WHOOSH);

    videoSetMode(MODE_5_3D);
    vramSetBankA(VRAM_A_TEXTURE);
    vramSetBankB(VRAM_B_TEXTURE);
    vramSetBankD(VRAM_D_TEXTURE);
    vramSetBankE(VRAM_E_TEX_PALETTE);

    // Sprite setup
    glScreen2D();
    double bg_x = 0;
    glImage bg_images[1];
    glLoadTileSet(bg_images,                                                                          // pointer to glImage array
                  512,                                                                                // sprite width
                  192,                                                                                // sprite height
                  512,                                                                                // bitmap width
                  192,                                                                                // bitmap height
                  GL_RGB256,                                                                          // texture type for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeX for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeY for glTexImage2D() in videoGL.h
                  GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
                  256,                                                                                // Length of the palette to use (256 colors)
                  (u16 *)bgLongPal,                                                                   // Load our 256 color tiles palette
                  (u8 *)bgLongBitmap                                                                  // image data generated by GRIT
    );

    glImage floor_images[1];
    glLoadTileSet(floor_images,                                                                       // pointer to glImage array
                  256,                                                                                // sprite width
                  192,                                                                                // sprite height
                  256,                                                                                // bitmap width
                  192,                                                                                // bitmap height
                  GL_RGB256,                                                                          // texture type for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeX for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeY for glTexImage2D() in videoGL.h
                  GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
                  256,                                                                                // Length of the palette to use (256 colors)
                  (u16 *)floorPal,                                                                    // Load our 256 color tiles palette
                  (u8 *)floorBitmap                                                                   // image data generated by GRIT
    );
    glImage bird_images[1];
    glLoadTileSet(bird_images,                                                                        // pointer to glImage array
                  256,                                                                                // sprite width
                  192,                                                                                // sprite height
                  256,                                                                                // bitmap width
                  192,                                                                                // bitmap height
                  GL_RGB256,                                                                          // texture type for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeX for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeY for glTexImage2D() in videoGL.h
                  GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
                  256,                                                                                // Length of the palette to use (256 colors)
                  (u16 *)birdPal,                                                                     // Load our 256 color tiles palette
                  (u8 *)birdBitmap                                                                    // image data generated by GRIT
    );
    glImage birdUp_images[1];
    glLoadTileSet(birdUp_images,                                                                      // pointer to glImage array
                  256,                                                                                // sprite width
                  192,                                                                                // sprite height
                  256,                                                                                // bitmap width
                  192,                                                                                // bitmap height
                  GL_RGB256,                                                                          // texture type for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeX for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeY for glTexImage2D() in videoGL.h
                  GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
                  256,                                                                                // Length of the palette to use (256 colors)
                  (u16 *)birdUpPal,                                                                   // Load our 256 color tiles palette
                  (u8 *)birdUpBitmap                                                                  // image data generated by GRIT
    );
    glImage birdDown_images[1];
    glLoadTileSet(birdDown_images,                                                                    // pointer to glImage array
                  256,                                                                                // sprite width
                  192,                                                                                // sprite height
                  256,                                                                                // bitmap width
                  192,                                                                                // bitmap height
                  GL_RGB256,                                                                          // texture type for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeX for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeY for glTexImage2D() in videoGL.h
                  GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
                  256,                                                                                // Length of the palette to use (256 colors)
                  (u16 *)birdDownPal,                                                                 // Load our 256 color tiles palette
                  (u8 *)birdDownBitmap                                                                // image data generated by GRIT
    );

    glImage pipeTop_images[1];
    glLoadTileSet(pipeTop_images,                                                                     // pointer to glImage array
                  26,                                                                                 // sprite width
                  161,                                                                                // sprite height
                  256,                                                                                // bitmap width
                  192,                                                                                // bitmap height
                  GL_RGB256,                                                                          // texture type for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeX for glTexImage2D() in videoGL.h
                  TEXTURE_SIZE_256,                                                                   // sizeY for glTexImage2D() in videoGL.h
                  GL_TEXTURE_WRAP_S | GL_TEXTURE_WRAP_T | TEXGEN_OFF | GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
                  256,                                                                                // Length of the palette to use (256 colors)
                  (u16 *)pipeTopPal,                                                                  // Load our 256 color tiles palette
                  (u8 *)pipeTopBitmap                                                                 // image data generated by GRIT
    );

    float yVel = 0;
    int score = 0;
    int floorXPos = 0;
    int floor2XPos = 252;
    int overCounter = 0;

    srand(time(0));
    Bird bird = Bird{77, 96};
    Pipe pipe1 = Pipe{276, 50 + (rand() % (143 - 49))};
    Pipe pipe2 = Pipe{276 + 69 + 5, 50 + (rand() % (143 - 49))};
    Pipe pipe3 = Pipe{276 + 69 * 2 + 10, 50 + (rand() % (143 - 49))};
    Pipe pipe4 = Pipe{276 + 69 * 3 + 15, 50 + (rand() % (143 - 49))};
    // Pipe pipeArray[] = {pipe1, pipe2, pipe3, pipe4};

    bool over = false;
    bool collided = false;
    // smackSound and floorSound booleans prevents death sound from infinitely playing
    bool smackSound = false;
    bool floorSound = true;
    // bool deathHigh = false;
    while (1)
    {

        scanKeys();

        glBegin2D();

        // SPRITES!!!
        // glSprite(bg_x, 0, GL_FLIP_NONE, bg_images);

        // glSprite(bg_x2,0,GL_FLIP_V,bg_images);
        // some logic to move background when off screen
        // if (bg_x == -256)
        //{
        //    bg_x = 0;
        //}
        glSprite(0, 0, GL_FLIP_NONE, bg_images);

        // DRAW PIPES & BIRD

        // draw Pipes
        // glBoxFilled(pipe1.pipeX, pipe1.pipeY - 25, pipe1.pipeX + 20, -10, RGB15(85, 255, 0));
        glSprite(pipe1.pipeX, pipe1.pipeY - 185, GL_FLIP_NONE, pipeTop_images);
        glSprite(pipe1.pipeX, pipe1.pipeY + 25, GL_FLIP_V, pipeTop_images);
        // glBoxFilled(pipe1.pipeX, pipe1.pipeY + 25, pipe1.pipeX + 20, 192, RGB15(85, 255, 0));

        // glBoxFilled(pipe2.pipeX, pipe2.pipeY - 25, pipe2.pipeX + 20, -10, RGB15(85, 255, 0));
        // glBoxFilled(pipe2.pipeX, pipe2.pipeY + 25, pipe2.pipeX + 20, 192, RGB15(85, 255, 0));
        glSprite(pipe2.pipeX, pipe2.pipeY - 185, GL_FLIP_NONE, pipeTop_images);
        glSprite(pipe2.pipeX, pipe2.pipeY + 25, GL_FLIP_V, pipeTop_images);

        // glBoxFilled(pipe3.pipeX, pipe3.pipeY - 25, pipe3.pipeX + 20, -10, RGB15(85, 255, 0));
        // glBoxFilled(pipe3.pipeX, pipe3.pipeY + 25, pipe3.pipeX + 20, 192, RGB15(85, 255, 0));
        glSprite(pipe3.pipeX, pipe3.pipeY - 185, GL_FLIP_NONE, pipeTop_images);
        glSprite(pipe3.pipeX, pipe3.pipeY + 25, GL_FLIP_V, pipeTop_images);

        // glBoxFilled(pipe4.pipeX, pipe4.pipeY - 25, pipe4.pipeX + 20, -10, RGB15(85, 255, 0));
        // glBoxFilled(pipe4.pipeX, pipe4.pipeY + 25, pipe4.pipeX + 20, 192, RGB15(85, 255, 0));
        glSprite(pipe4.pipeX, pipe4.pipeY - 185, GL_FLIP_NONE, pipeTop_images);
        glSprite(pipe4.pipeX, pipe4.pipeY + 25, GL_FLIP_V, pipeTop_images);

        // Floor sprites
        if (floorXPos == -252)
        {
            floorXPos = 252;
        }
        if (floor2XPos == -252)
        {
            floor2XPos = 252;
        }

        glSprite(floorXPos, 176, GL_FLIP_NONE, floor_images);
        glSprite(floor2XPos, 176, GL_FLIP_NONE, floor_images);

        // draw bird
        // glBoxFilled(bird.xPos, bird.yPos, bird.xPos + 10, bird.yPos + 10, RGB15(102, 255, 255));
        if (!over)
        {
            if (yVel < -.7)
            {
                // glSprite(bird.xPos-129, bird.yPos-90, GL_FLIP_NONE, birdDown_images);
                glSpriteRotate(bird.xPos, bird.yPos + 4, yVel * 1000, GL_FLIP_NONE, birdDown_images);
            }
            else if (yVel < 1)
            {
                // glSprite(bird.xPos-129, bird.yPos-90, GL_FLIP_NONE, bird_images);
                glSpriteRotate(bird.xPos, bird.yPos + 4, yVel * 1000, GL_FLIP_NONE, bird_images);
            }
            else
            {
                // glSprite(bird.xPos-129, bird.yPos-90, GL_FLIP_NONE, birdUp_images);
                glSpriteRotate(bird.xPos, bird.yPos + 4, yVel * 1000, GL_FLIP_NONE, birdUp_images);
            }
        }
        else
        {
            glSpriteRotate(bird.xPos, bird.yPos, yVel * 1000, GL_FLIP_NONE, birdUp_images);
        }
        if ((collided || over) && overCounter < 5){
            glBoxFilled(0, 0, 256, 192, RGB15(255, 255, 255));
            overCounter++;
        }
        // glSpriteRotate(bird.xPos-3, bird.yPos-1, yVel*1000,GL_FLIP_NONE, bird_images);

        // COLLISIONS

        // looping attempt
        // looping through pipe array doesnt work :( need 2 figure out why
        /*
        for (Pipe x : pipeArray){
            if (
             //  compare bird yPos with top half of pipe's yPos
                 ((bird.yPos<=x.pipeY-25)
             //  compare bird yPos with bottom half of pipe's yPos
             ||  (bird.yPos+10>(x.pipeY+25)))
             //  check if bird is within pipe's xPos
             &&  ((bird.xPos+10 >= x.pipeX)  &&  (bird.xPos <= x.pipeX+20))
             ){
             collided = true;
            }
        }
        */

        // working collisions
        if ((!over) && ((
                            //  compare bird yPos with top half of pipe's yPos
                            ((bird.yPos <= pipe1.pipeY - 25)
                             //  compare bird yPos with bottom half of pipe's yPos
                             || (bird.yPos + 10 > (pipe1.pipeY + 25)))
                            //  check if bird is within pipe's xPos
                            && ((bird.xPos + 5 >= pipe1.pipeX) && (bird.xPos <= pipe1.pipeX + 24))) ||
                        (((bird.yPos <= pipe2.pipeY - 25) || (bird.yPos + 10 > (pipe2.pipeY + 25))) && ((bird.xPos + 5 >= pipe2.pipeX) && (bird.xPos <= pipe2.pipeX + 24))) || // same thing for pipe2
                        (
                            ((bird.yPos <= pipe3.pipeY - 25) || (bird.yPos + 10 > (pipe3.pipeY + 25))) && ((bird.xPos + 5 >= pipe3.pipeX) && (bird.xPos <= pipe3.pipeX + 24))) || // same thing for pipe3
                        (
                            ((bird.yPos <= pipe4.pipeY - 25) || (bird.yPos + 10 > (pipe4.pipeY + 25))) && ((bird.xPos + 5 >= pipe4.pipeX) && (bird.xPos <= pipe4.pipeX + 24)))) // same thing for pipe4

        )
        {
            /*
            if      (((bird.xPos + 10 >= pipe1.pipeX) && (bird.xPos <= pipe1.pipeX + 20)) && (bird.yPos <= pipe1.pipeY - 25)){
                deathHigh = true;
            }
            else if (((bird.xPos + 10 >= pipe3.pipeX) && (bird.xPos <= pipe3.pipeX + 20)) && (bird.yPos <= pipe2.pipeY - 25)){
                deathHigh = true;
            }
            else if (((bird.xPos + 10 >= pipe3.pipeX) && (bird.xPos <= pipe3.pipeX + 20)) && (bird.yPos <= pipe3.pipeY - 25)){
                deathHigh = true;
            }
            else if (((bird.xPos + 10 >= pipe4.pipeX) && (bird.xPos <= pipe4.pipeX + 20)) && (bird.yPos <= pipe4.pipeY - 25)){
                deathHigh = true;
            }
            else {
                deathHigh = false;
            }*/
            collided = true;
            over = true;
            smackSound = true;
        }

        /*
        if (smackSound && deathHigh)
        {
            mmEffect(SFX_SMACKWHOOSHSLOW);
            smackSound = false;
        }
        else if (smackSound && !deathHigh)
        {
            mmEffect(SFX_SMACKWHOOSHQUICK);
            smackSound = false;
        }*/
        if (smackSound)
        {
            mmEffect(SFX_SMACK);
            smackSound = false;
        }

        // SCORE
        if ((!collided) &&
            ((pipe1.pipeX == bird.xPos) || (pipe2.pipeX == bird.xPos) || (pipe3.pipeX == bird.xPos) || (pipe4.pipeX == bird.xPos)))
        {
            score++;
            // play sound!
            mmEffect(SFX_DING);
        }

        if (!over)
        {
            // move pipes towards bird if not yet collided
            if (!collided)
            {
                pipe1.pipeX -= 1;
                pipe2.pipeX -= 1;
                pipe3.pipeX -= 1;
                pipe4.pipeX -= 1;
                bg_x -= 0.5;
                floorXPos -= 1;
                floor2XPos -= 1;
            }
        }

        // reset pipes once they move off screen
        if (pipe1.pipeX <= -26)
        {
            pipe1.pipeX = 276;
            pipe1.pipeY = 50 + (rand() % (143 - 49));
        }
        if (pipe2.pipeX <= -26)
        {
            pipe2.pipeX = 276;
            pipe2.pipeY = 50 + (rand() % (143 - 49));
        }
        if (pipe3.pipeX <= -26)
        {
            pipe3.pipeX = 276;
            pipe3.pipeY = 50 + (rand() % (143 - 49));
        }
        if (pipe4.pipeX <= -26)
        {
            pipe4.pipeX = 276;
            pipe4.pipeY = 50 + (rand() % (143 - 49));
        }

        // MOVEMENT
        if (!over)
        {
            if (keysDown())
            {
                // move bird upwards
                yVel = -2.2;
                // play flap sound
                mmEffect(SFX_FLAP);
            }
        }

        if (!over)
        {
            bird.yPos += yVel;
            yVel += .125;
        }
        if (over && bird.yPos != 170)
        {
            bird.yPos += yVel;
            yVel += .125;
        }

        // dont let bird go out of the screen
        // prevents from leaving bottom
        if (bird.yPos >= 170)
        {
            if (floorSound && !collided)
            {
                mmEffect(SFX_SMACK);
                floorSound = false;
            }
            bird.yPos = 170;
            over = true;
        }

        // BOTTOM SCREEN

        // printing and testing
        clrscr();

        /*iprintf("yPos=%d\n", bird.yPos); 
         iprintf("pipe1X=%d\n", pipe1.pipeX);
         iprintf("pipe1Y=%d\n", pipe1.pipeY);
         iprintf("collided?=%s\n", collided ? "true" : "false");
         */
        iprintf("\n\n\n\n\n\t\tScore=%d\n", score);

        if (over && bird.yPos == 170)
        {
            clrscr();
            //iprintf("\n\nyPos=%d\n", bird.yPos);
            iprintf("\n\n\n\n\n\n\n\n\n\t\t\t\tGame Over!\n");
            iprintf("  Press START button to restart");
            iprintf("\n\n\n\n\n\t\t  Final Score=%d\n", score);
            over = true;
        }

        // Restart game
        int currentKeysDown = keysDown();
        if ((KEY_START & currentKeysDown) && over)
        {
            bird.yPos = 96;
            yVel = 0;
            srand(time(0));
            pipe1.pipeX = 276;
            pipe1.pipeY = 50 + (rand() % (143 - 49));
            pipe2.pipeX = 276 + 69 + 5;
            pipe2.pipeY = 50 + (rand() % (143 - 49));
            pipe3.pipeX = 276 + 69 * 2 + 10;
            pipe3.pipeY = 50 + (rand() % (143 - 49));
            pipe4.pipeX = 276 + 69 * 3 + 15;
            pipe4.pipeY = 50 + (rand() % (143 - 49));
            floorXPos = 0;
            floor2XPos = 252;
            overCounter = 0;
            score = 0;
            over = false;
            collided = false;
            floorSound = true;
        }

        glFlush(0);
        swiWaitForVBlank();
    }
    return 0;
}